================================================================================
UNITY FİZİK DETAYLI ANALİZİ: Pitch, Yaw, Roll
================================================================================

MEVCUT KOD İNCELEMESİ:
================================================================================

1. APPLYPHYSICS() METODU:
```csharp
private void ApplyPhysics(float pitch, float yaw, float thrust, float roll)
{
    float motorGucu = Mathf.Clamp01(thrust);
    rocketRb.AddRelativeForce(Vector3.up * motorGucu * mainThrustPower);

    Vector3 pitchTork = transform.right * pitch * rcsPower;
    Vector3 yawTork   = transform.forward * yaw * rcsPower;
    Vector3 rollTork  = transform.up * roll * (rcsPower * 0.1f);

    rocketRb.AddTorque(pitchTork + yawTork + rollTork);
}
```

2. PARSFLOAT() METODU:
```csharp
private float ParseFloat(string value)
{
    if (float.TryParse(value, NumberStyles.Any, CultureInfo.InvariantCulture, out float result))
    {
        return result;
    }
    return 0.0f;  // ← SORUN: Parse edilemezse 0 döndürüyor!
}
```

3. RESETENV():
```csharp
transform.rotation = Quaternion.Euler(pitch, yaw, 0f);  // ← Roll her zaman 0!
```

================================================================================
KRİTİK SORUNLAR:
================================================================================

SORUN 1: PARSFLOAT() BIAS'I
- Parse edilemezse 0.0f döndürüyor
- Eğer action değeri yanlış parse edilirse → 0 olur
- Bu bir bias yaratabilir (her zaman 0'a düşme riski)

SORUN 2: ROLL RESET'TE SABİT
- ResetEnv'de roll her zaman 0f
- Initial rotation'da roll bias'ı yok
- Bu normal ama kontrol edilmeli

SORUN 3: ROLL TORK ÇOK ZAYIF
- rollTork = transform.up * roll * (rcsPower * 0.1f)
- rcsPower * 0.1 = 1200 * 0.1 = 120 N (çok zayıf!)
- Pitch/Yaw: 1200 N
- Roll: 120 N (10x daha zayıf)
- Bu kasıtlı mı? (Roll genelde daha zayıf olabilir)

SORUN 4: ADDTORQUE() vs ADDRELATIVETORQUE()
- AddTorque() → World space'de tork uygular
- AddRelativeTorque() → Local space'de tork uygular
- transform.right/forward/up → Local space vektörleri
- AddTorque(transform.right * ...) → Doğru mu?
  - Evet! AddTorque world space alır ama transform vektörleri zaten world space'e çevrilmiş

SORUN 5: PITCH/YAW/ROLL EKSEN EŞLEŞMESİ
- Pitch: transform.right (X ekseni) - Öne arkaya yatma
- Yaw: transform.forward (Z ekseni) - Sağa sola yatma
- Roll: transform.up (Y ekseni) - Kendi ekseninde dönme
- Bu Unity convention'ına göre doğru mu?

Unity Convention:
- Pitch: X ekseni (sağ-sol) - transform.right
- Yaw: Y ekseni (yukarı-aşağı) - transform.up
- Roll: Z ekseni (ileri-geri) - transform.forward

AMA KOD:
- Pitch: transform.right (X) ✓
- Yaw: transform.forward (Z) ✗ (Roll olmalı!)
- Roll: transform.up (Y) ✗ (Yaw olmalı!)

←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←
KRİTİK BULGU: EKSEN EŞLEŞMESİ YANLIŞ OLABİLİR!
←←←←←←←←←←←←←←←←←←←←←←←←←<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Unity'de Quaternion.Euler(pitch, yaw, roll) sırası:
- X (pitch): Öne-arkaya yatma
- Y (yaw): Sağa-sola dönme (yaw)
- Z (roll): Kendi ekseninde dönme

Kod:
```csharp
transform.rotation = Quaternion.Euler(pitch, yaw, 0f);
```

Ama ApplyPhysics'te:
- Pitch → transform.right (X ekseni) ✓ DOĞRU
- Yaw → transform.forward (Z ekseni) ✗ YANLIŞ! (Bu roll ekseni!)
- Roll → transform.up (Y ekseni) ✗ YANLIŞ! (Bu yaw ekseni!)

←←←←←←←←←←←←←←←←←←←←←<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
SORUN: YAW VE ROLL EKSENLERİ KARIŞMIŞ!
←←←←←←<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

================================================================================
DOĞRU EKSEN EŞLEŞMESİ:
================================================================================

Unity'de:
- X ekseni: Pitch (öne-arkaya yatma) → transform.right ✓
- Y ekseni: Yaw (sağa-sola dönme) → transform.up
- Z ekseni: Roll (kendi ekseninde dönme) → transform.forward

ŞU ANKİ KOD (YANLIŞ):
```csharp
Vector3 pitchTork = transform.right * pitch * rcsPower;      // X → Pitch ✓
Vector3 yawTork   = transform.forward * yaw * rcsPower;      // Z → Yaw ✗ (Z = Roll!)
Vector3 rollTork  = transform.up * roll * (rcsPower * 0.1f); // Y → Roll ✗ (Y = Yaw!)
```

DOĞRU KOD:
```csharp
Vector3 pitchTork = transform.right * pitch * rcsPower;      // X → Pitch ✓
Vector3 yawTork   = transform.up * yaw * rcsPower;           // Y → Yaw ✓
Vector3 rollTork  = transform.forward * roll * (rcsPower * 0.1f); // Z → Roll ✓
```

================================================================================
ETKİSİ:
================================================================================

Eğer eksenler karışıksa:
- Agent "yaw" komutu veriyor ama roket "roll" yapıyor!
- Agent "roll" komutu veriyor ama roket "yaw" yapıyor!
- Bu yüzden agent hep aynı tarafa gidiyor olabilir!
- Control confusion → agent doğru action'ı öğrenemiyor!

================================================================================
DİĞER OLASI SORUNLAR:
================================================================================

1. PARSFLOAT() DEFAULTO 0.0:
   - Parse hatası olursa action 0 olur
   - Bu bir bias yaratabilir
   - Ama büyük ihtimalle parse ediliyor

2. ROLL TORK ZAYIF:
   - Roll: 120 N (10x daha zayıf)
   - Bu kasıtlı olabilir ama test edilmeli

3. ADDTORQUE() WORLD SPACE:
   - transform.right/forward/up zaten world space'e çevrilmiş
   - AddTorque() world space alır
   - Bu doğru görünüyor

================================================================================
ÖNERİLEN DÜZELTMELER:
================================================================================

1. ✅ DÜZELTİLDİ: Eksen Eşleşmesi Düzeltildi
   ```csharp
   Vector3 pitchTork = transform.right * pitch * rcsPower;        // X → Pitch ✓
   Vector3 yawTork   = transform.up * yaw * rcsPower;             // Y → Yaw ✓ (DÜZELTME: forward → up)
   Vector3 rollTork  = transform.forward * roll * (rcsPower * 0.1f); // Z → Roll ✓ (DÜZELTME: up → forward)
   ```
   - Önceki kod: yaw→forward (Z), roll→up (Y) YANLIŞTI
   - Yeni kod: Unity convention'ına uygun

2. PARSFLOAT() İyileştir (İLERİYE DÖNÜK)
   - Parse hatası durumunda loglama ekle
   - Veya NaN/Infinity kontrolü
   - Şu an çalışıyor gibi görünüyor

3. ROLL TORK Gücü Test Et (İLERİYE DÖNÜK)
   - 0.1f → 0.2f veya 0.3f (daha güçlü roll)
   - Önce eksen düzeltmesini test et

================================================================================
TEST:
================================================================================

Eksenlerin doğru olup olmadığını test etmek için:
- Unity'de test: Pitch komutu ver → X ekseni etrafında dönmeli ✓
- Unity'de test: Yaw komutu ver → Y ekseni etrafında dönmeli ✓
- Unity'de test: Roll komutu ver → Z ekseni etrafında dönmeli ✓

YENİ KOD (DÜZELTME SONRASI):
- Pitch komutu → transform.right (X) → DOĞRU ✓
- Yaw komutu → transform.up (Y) → DOĞRU ✓ (DÜZELTME: forward → up)
- Roll komutu → transform.forward (Z) → DOĞRU ✓ (DÜZELTME: up → forward)

ETKİSİ:
- Agent artık doğru eksenlerde kontrol yapabilir
- "Hep aynı tarafa gitme" sorunu çözülmeli
- Agent doğru action→response mapping'i öğrenebilir

================================================================================
KONSOL ÇIKTISI SORUNU DA DÜZELTİLDİ:
================================================================================

- PID ve timestamp eklendi: Multiple instance'ları ayırt etmek için
- flush=True: Buffer sorununu çözer
- Artık hangi process'in ne zaman log yazdığını görebilirsin

================================================================================

