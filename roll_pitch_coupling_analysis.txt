================================================================================
ROLL-PITCH COUPLING ANALİZİ
================================================================================

MEVCUT KOD:
================================================================================
```csharp
Vector3 pitchTork = transform.right * pitch * rcsPower;        // X ekseni
Vector3 yawTork   = transform.up * yaw * rcsPower;             // Y ekseni
Vector3 rollTork  = transform.forward * roll * (rcsPower * 0.1f); // Z ekseni

rocketRb.AddTorque(pitchTork + yawTork + rollTork);
```

SORUN:
================================================================================

1. TRANSFORM VEKÖRLERİ LOCAL SPACE'DE
   - transform.right: Roket'in sağa doğru yönü (local space)
   - transform.up: Roket'in yukarı doğru yönü (local space)
   - transform.forward: Roket'in ileri doğru yönü (local space)

2. ROLL DÖNMESİ ETKİSİ
   - Roket roll yaptığında (kendi ekseni etrafında döndüğünde)
   - transform.right ve transform.up da döner!
   - Örnek: 90° roll yaparsa:
     * transform.right → önceki transform.up'a döner
     * transform.up → önceki -transform.right'a döner

3. PITCH TORKUNUN YÖNÜ DEĞİŞİR
   - Roll yapılmadan önce: pitch torku doğru yönde (örneğin sağa)
   - 90° roll yapıldıktan sonra: pitch torku yanlış yönde (örneğin yukarı)
   - Agent pitch komutu veriyor ama roket farklı yönde dönüyor!

ÖRNEK:
================================================================================

Başlangıç: Roket düz (roll=0°)
- Agent: pitch=+1 (öne yat)
- pitchTork = transform.right * (+1) * 1200
- Tork doğru yönde uygulanır ✓

Roll yapıldı: 90° roll
- transform.right → önceki transform.up'a döner
- Agent: pitch=+1 (öne yat)
- pitchTork = transform.right * (+1) * 1200
- Ama artık transform.right yukarı baktığı için tork yukarı yönde!
- Roket öne değil, yukarı dönmeye çalışır ✗

SONUÇ:
================================================================================

✅ ROLL PITCH'İ ETKİLİYOR!
✅ ROLL YAW'ı ETKİLİYOR!

Bu yüzden:
- Agent pitch komutu verdiğinde roket farklı yönde dönebilir
- Roll yapıldıktan sonra pitch/yaw kontrolü kaybolabilir
- Agent öğrenmesi zorlaşır (action→response mapping karmaşık)

ÇÖZÜM:
================================================================================

AddTorque'da WORLD SPACE vektörleri kullanmalıyız!

Şu anki (YANLIŞ):
```csharp
Vector3 pitchTork = transform.right * pitch * rcsPower;  // LOCAL SPACE
Vector3 yawTork   = transform.up * yaw * rcsPower;       // LOCAL SPACE
Vector3 rollTork  = transform.forward * roll * rcsPower; // LOCAL SPACE
```

Doğru (WORLD SPACE):
```csharp
// Pitch: Dünya X ekseninde (öne-arkaya)
Vector3 pitchTork = Vector3.right * pitch * rcsPower;

// Yaw: Dünya Y ekseninde (sağa-sola)
Vector3 yawTork = Vector3.up * yaw * rcsPower;

// Roll: Dünya Z ekseninde (kendi ekseni etrafında)
Vector3 rollTork = Vector3.forward * roll * rcsPower;
```

AMA BEKLE:
================================================================================

Unity'de roket dikey başlıyor (up = world up). Ama döndükçe:
- Roket 45° pitch yaptığında, "öne yat" ne demek?
- Dünya koordinatında mı? Roket koordinatında mı?

Bu durumda iki yaklaşım var:

1. WORLD SPACE (Sabit referans):
   - Pitch = dünya X ekseni (her zaman aynı)
   - Agent'ın öğrenmesi daha kolay
   - Ama roket döndükçe "öne yat" komutu garip olabilir

2. LOCAL SPACE (Roket referansı):
   - Pitch = roket'in sağı (her zaman roket'e göre)
   - Agent'ın öğrenmesi daha zor (roll coupling var)
   - Ama "öne yat" her zaman roket'in önüne göre

GERÇEKÇİ YAKLAŞIM:
================================================================================

Roketlerde genelde LOCAL SPACE kullanılır (pitch = roket'in burnunu yukarı/aşağı).
Ama roll coupling'i önlemek için:

Yaklaşım 1: AddRelativeTorque kullan (Unity öneriyor)
```csharp
rocketRb.AddRelativeTorque(pitchTork + yawTork + rollTork);
// AddRelativeTorque otomatik olarak roll coupling'i handle eder
```

Yaklaşım 2: Rotation matris kullan (daha kompleks)
```csharp
// Roll etkisini hesapla ve pitch/yaw torklarını düzelt
Quaternion rollRotation = Quaternion.AngleAxis(rollAngle, transform.forward);
Vector3 correctedPitchTork = rollRotation * pitchTork;
```

Yaklaşım 3: World space'e çevir (basit ama gerçekçi olmayabilir)
```csharp
Vector3 pitchTork = Vector3.right * pitch * rcsPower; // World space
```

ÖNERİ:
================================================================================

AddRelativeTorque kullan! Unity bunu handle ediyor.

✅ UYGULANDI:
- AddTorque → AddRelativeTorque değiştirildi
- Vector3.right/up/forward kullanılıyor (local space)
- AddRelativeTorque otomatik olarak roll coupling'i handle eder

BEKLENEN ETKİ:
- Roll yapıldığında pitch/yaw torkları doğru yönde kalır
- Agent action→response mapping'i daha tutarlı olur
- "Hep aynı tarafa gitme" sorunu azalabilir

================================================================================

